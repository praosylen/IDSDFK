from collections import defaultdict
from sys import exit, stdout, argv

#Do nothing no matter what:
ACTION_NULL = lambda *args, **kwargs: None

#Class used to disguise a global variable representing all instructions supported
class Instruction:
    
    #Class variable storing the action generator corresponding to each instruction symbol
    #Action generators are (contrary to the name) ordinary functions, and should take two
    #    or more arguments:
    #        env: a reference to the environment being used
    #        name: the variable or subroutine name taken by the action as an argument, in
    #            the form of a lambda returning that name as a hashable type (should be
    #            an integer or string).
    #        And any extra arguments specific to the instruction in question and defined
    #            by the Unit calling it. (Typically will be another Unit, in the form of
    #            a lambda returning it.)
    #    And return a function (action) taking two arguments "subr" (the name of the
    #        current subroutine) and "next" (a Unit instance or ACTION_NULL representing
    #        the next instruction (if any) in the code), whose return value will be
    #        ignored.
    #Action generators for unimplemented instructions (which should never make it this
    #    far anyway) return a callback doing nothing.
    action_gens = defaultdict(lambda: (lambda *args: ACTION_NULL))
    
    #The Instruction() constructor is essentially used to add a new instruction to the
    #    action_gens defaultdict, rather than generating a useful instruction in its own
    #    right. As such, it could probably be replaced with a similar function outside the
    #    class definition. As before, "env" (a parameter also used to disguise the
    #    unnecessary nature of this class) is a reference to the environment being used.
    #    "symbol" is a one-character symbol for the instruction. "action_gen" is an
    #    action generator as described above.
    def __init__(self, env, symbol, action_gen):
        
        #Continue the fa[c with cedilla]ade -- sure, this is totally an important class
        #   that actually does something... see, I've even got instance properties!
        self.symbol = symbol
        self.action_gen = action_gen
        self.env = env
        
        #The only important line in this entire function:
        self.action_gens[symbol] = action_gen
    
    #In case you ever want to call an Instruction instance -- not sure why...
    def __call__(self, *args, **kwargs):
        return self.action_gen(self.env, *args, **kwargs)

#A Unit is the basic component of code. It consists of a single instruction symbol and its
#arguments, which include a single variable or subroutine name as well as potentially a
#reference to a subroutine it defines, as well as a pointer to the next Unit in the code.
class Unit:
    
    #Not fully fleshed out yet, but see above description. "arguments" should be a list
    #    of parameters that can be passed into an action generator. "next", as described
    #    above with the definition of an action generator, is a reference to the next Unit
    #    in the code if it exists, or ACTION_NULL if not.:
    def __init__(self, symbol, arguments, next):
        self.symbol = symbol
        self.arguments = arguments
        self.next = next
    
    #Return an action callback doing whatever this Unit does, generated by this unit's
    #    instruction's action generator.
    def get_action(self):
        return Instruction.action_gens[self.symbol](*self.arguments)
    
    #Do the action corresponding to this Unit by calling it. Typically, this will add the
    #    Unit referenced by self.next to the environment's timeouts if it exists, although
    #    *when* this occurs is up to the action.
    def __call__(self, subr):
        return self.get_action()(subr, self.next)
    
    #For debugging purposes:
    def __repr__(self):
        return "Unit(%r, %r, %r)" % (self.symbol, [self.arguments[0]] + map(lambda x: "lambda %r" % x(), self.arguments[1:]), self.next)
    def __eq__(self, other):
        return self.symbol == other.symbol and map(lambda a,b: a()==b(), self.arguments[1:], other.arguments[1:]) and (self.next is other.next or self.next == other.next)

#The entire runtime environment of the code. Contains variables, subroutines, timeouts,
#    and the current timestep in addition to code previously parsed into Units. Handles
#    code execution once it has been parsed.
class Environment:

    #Read stdin one character at a time.
    class Stdin:
        def __init__(self):
            self.buffer = ""
        def __call__(self):
            if not len(self.buffer):
                try:
                    self.buffer += raw_input()
                except EOFError:
                    pass
                if not len(self.buffer):
                    self.buffer += "\0" #Null bytes indicate end of input
            rtn = self.buffer[0]
            self.buffer = self.buffer[1:]
            return rtn

    #Initialize environment.
    def __init__(self, debug=False):
        self.stdin = self.Stdin()
        
        #Variables are 0 by default
        self.vars = defaultdict(int)
        
        #Subroutines do nothing by default
        self.subs = defaultdict(lambda: ACTION_NULL)
        #Unless...
        
        #Output is done by forking the ">" subroutine, which converts the value of the ">"
        #    variable into a character (mod 256) and writes it to stdout. This function \
        #    mimics Unit.__call__.
        def output(*args):
            stdout.write(chr(self.vars[">"]))
            return ACTION_NULL
        self.subs[">"] = output
        
        #Input is done by forking the "<" subroutine, which reads a byte from stdin and
        #    stores it in the variable "<". This function mimics Unit.__call__.
        def input_(*args):
            self.vars["<"] = ord(self.stdin())
            return ACTION_NULL
        self.subs["<"] = input_
        
        #Time begins at 0. The runtime time variable does not represent the real time
        #    elapsed, thankfully for you the programmer -- intervals of time in which
        #    nothing is happening are, in fact, skipped entirely.
        self.t = 0
        
        #Stores the actions to be taken in a defined time order. Organized first by
        #    timestep and then by order of addition.
        self.timeouts = defaultdict(list)
        
        #Add action generators for each instruction:
        #Increment a variable "name" using "+name"
        def increment(env, name):
            #This is the callback which will be returned by the action generator and then
            #    called by Unit.__call__
            #Parameters: "subr", the name of the current subroutine | "next", the next
            #    Unit in the code or a callback.
            def action(subr, next):
                #Increment variable "name"
                env.vars[name()] += 1
                #Execute next instruction (Unit) during current timestep, passing on the
                #    subroutine name to the timeouts defaultdict to be stored
                env.timeout(next, subr)
            #Return the callback
            return action
        #Add it to Instruction.action_gens
        Instruction(self, "+", increment)
        
        #Decrement a variable "name" using "-name"
        def decrement(env, name):
            def action(subr, next):
                env.vars[name()] -= 1
                env.timeout(next, subr)
            return action
        Instruction(self, "-", decrement)
        
        #Sleep (delay execution of the next instruction) for the amount of time stored in
        #    variable "name" using "_name"
        def sleep(env, name):
            #Simple enough a lambda can be used: add an extra parameter "dt" to
            #    Environment.timeout to set the timeout for the current time + dt
            return lambda subr, next: env.timeout(next, subr, env.vars[name()])
        Instruction(self, "_", sleep)
        
        #Define a subroutine named "name" beginning with the Unit "code" using
        #    ":name(...)", where ... is the code of the subroutine
        def define(env, name, code):
            def action(subr, next):
                #Add a subroutine with name "name" and first Unit "code"
                env.subs[name()] = code()
                #Don't run it, though -- just keep going with the parent subroutine
                env.timeout(next, subr)
            return action
        Instruction(self, ":", define)
        
        #Fork a new execution path running subroutine "name" using "#name"
        def fork(env, name):
            def action(subr, next):
                #Add two timeouts this time. The child subroutine receives earlier
                #    precedence than the parent one.
                env.timeout(env.subs[name()], name())
                env.timeout(next, subr)
            return action
        Instruction(self, "#", fork)
        
        #Kill running subroutines with the given "name"", if they exist (otherwise do
        #    nothing) using "/name"
        def kill(env, name):
            def action(subr, next):
                if subr == name(): return #Allow killing current process
                for i in self.timeouts:
                    for j in self.timeouts[i]:
                        #print j[0], name
                        if j[0] == name():
                            #Replace action callbacks for the running subroutines with
                            #    null lambdas (since subroutines perpetuate themselves by
                            #    adding their next Unit to env.timeouts within their
                            #    action callbacks, this eliminates both extant and yet-to-
                            #    be-added Units from the execution process.)
                            j[1] = ACTION_NULL
                env.timeout(next, subr)
            return action
        Instruction(self, "/", kill)
        
        def print_(env, name):
            def action(subr, next):
                print "\n" + str(name()) + ":", env.vars[name()]
                env.timeout(next, subr)
            return action
        if debug:
            Instruction(self, "!", print_)
    
    #Execute all actions scheduled for a given timestep, then advance to the next timestep
    #    when something is happening
    def tick(self):
        for i in self.timeouts[self.t]:
            #Call the next action (Unit.__call__ or ACTION_NULL), passing the subroutine
            #    name added in self.timeout() by an action callback and thus continuing
            #    the subroutine perpetuation cycle
            #print self.t, self.timeouts
            i[1](i[0])
        
        #Determine next timestep when something's happening
        future_timeouts = filter(lambda t: t > self.t, self.timeouts.keys())
        
        #Memory manage
        del self.timeouts[self.t]
        
        #Advance to predetermined timestep if there are any actions scheduled.
        if len(future_timeouts):
            self.t = min(future_timeouts)
    
    #Add an action to be executed as part of a specified subroutine after a specified
    #    amount of time (defaulting to zero)
    def timeout(self, action, subr, dt=0):
        #Add to self.timeouts (after the existing actions taking place at self.t+dt),
        #    making sure to keep track of the subroutine name.
        self.timeouts[self.t+max(dt,0)].append([subr, action])
    
    #Call within an action callback to exit the program with a given error message.
    def error(self, err):
        print("Fatal error: " + err)
        exit()
    
    #Actually run the code. "main" should be a reference to the first Unit in the parsed
    #    code, and can be referenced in code as a subroutine named "0".
    def __call__(self, main):
        #Store main code as a subroutine
        self.subs["0"] = main
        
        #Ensure the main code actually gets run
        self.timeout(main, "0")
        
        #Run until nothing's scheduled anymore.
        while(len(self.timeouts)):
            #Execute all scheduled timeouts then advance.
            self.tick()

#env = Environment()
#env(Unit("#", [env, lambda: "<"], Unit("+", [env, lambda: "<"], Unit("+", [env, lambda: "<"], Unit("_", [env, lambda: "<"], Unit("#", [env, lambda: ">"], ACTION_NULL))))))

#Parses the source code into a treelike structure of Units, which can be run as-is
class Parser:
    #Input code as a string
    def __init__(self, env, code):
        self.env = env
        #Eliminate whitespace
        self.code = code.replace(" ","").replace("\n","").replace("\r","").replace("\t","").replace("\f","").replace("\v","")
        self.tokenized = self.tokenize()
        self.unitized = self.unitize()
    
    #Get names of valid instructions:
    @property
    def instructions(self):
        return Instruction.action_gens.keys()
    
    def error(self, err):
        print("Fatal error: " + err)
        exit()
    
    #Recursively break up code into groups of tokens consisting of an instruction followed
    #    by its arguments (which can themselves be other blocks of code). Each list of
    #    an instruction and its arguments will be in forward order, but lists of these
    #    lists will be in reverse order.
    def tokenize(self, code=None):
        if code == None:
            code = self.code
        #Find the closing delimiter in str_ corresponding to the opening one at index idx.
        #    Optional parameters open and close should be functions taking a single
        #    character argument and returning whether or not it's a valid delimiter of the
        #    corresponding type. Returns the closing delimiter's index if it exists, or
        #    None otherwise.
        def find_close(str_, idx, open="(".__eq__, close=")".__eq__):
            lvl = 1
            while lvl:
                idx += 1
                if idx >= len(str_):
                    return None
                #print idx, lvl, str_, str_[idx], close(str_[idx])
                if open(str_[idx]):
                    lvl += 1
                elif close(str_[idx]):
                    lvl -= 1
            return idx
        
        is_inst = lambda c: c in self.instructions
        idx = find_close(code, -1, lambda c:False, is_inst)
        if idx is None:
            idx = len(code)
        #print idx
        tree = []
        while idx < len(code):
            #Preliminary guess for the next instruction's location
            next_inst = find_close(code, idx, lambda c:False, is_inst) or len(code)
            
            #Parenthesized blocks's locations
            par_blocks = []
            
            #The current instruction plus its arguments as a list of tokens
            inst_plus_args = [code[idx]]
            
            #Locate and jump past parenthesized blocks and readjust guess as necessary
            idx2 = idx
            while idx2 < next_inst:
                #If an open parenthesis is read, advance to next close parenthesis and
                #    note the parenthesized block
                if code[idx2] == "(":
                    close = find_close(code, idx2)
                    #print next_inst
                    par_blocks.append((idx2, close))
                    idx2 = close
                    if idx2 == None:
                        self.error("Missing close parenthesis.")
                
                idx2 += 1
                
                #Close parenthesis is after next instruction
                if idx2 > next_inst:
                    #Readjust guess
                    next_inst = find_close(code, idx2-1, lambda c:False, is_inst) or len(code)
            
            idx2 = idx+1
            for s, e in par_blocks:
                if s > idx2:
                    #Everything between the end of the last token and the start of the
                    #    parenthesized block constitutes a token
                    inst_plus_args.append(code[idx2:s])
                #A parenthesized block gets recursively tokenized
                inst_plus_args.append(self.tokenize(code[s+1:e]))
                idx2 = e+1
            #If there aren't any parenthesized blocks or there's something left over after
            #    the last one, what remains is a token
            if idx2 < next_inst:
                inst_plus_args.append(code[idx2:next_inst])
            #Add it to the tree of tokenized code. Why is it a tree? Because this is
            #    getting returned, and if that's in the context of a parenthesized block,
            #    it will itself be added to a list of tokens and then this very list in
            #    a higher-level call of this function.
            tree.insert(0, inst_plus_args)
            idx = next_inst
        return tree
    
    #Convert tokenized code into a tree of Units.
    def unitize(self, tokenized=None):
        #Fight complicated closure issues with more complicated closure issues
        def make_lambda_1(q):
            return lambda: self.env.vars[q]
        def make_lambda_2(q):
            return lambda: q
        
        if tokenized is None:
            tokenized = self.tokenized
        currunit = ACTION_NULL
        for i in tokenized:
            i2 = []
            #Convert tokens into lambdas which can be passed as arguments to an action
            #    generator. Discard the first token (the instruction) for the time being.
            for j in i[1:]:
                #A normal token representing a name
                if isinstance(j, str):
                    #Prefacing a variable name with @ makes it refer to the variable or
                    #    subroutine name given by the integer stored by the variable.
                    #CONSIDER MODIFYING TO ALLOW RECURSIVE USE OF @!!!
                    if j[0] == "@":
                        #These had to be replaced from inline lambdas to lambda-generating
                        #    functions because with the inline lambdas the variable j
                        #    persisted around iterations of the loop and made all of the
                        #    lambdas for different units return the same value. This isn't
                        #    something one normally has to think about in Python.
                        i2.append(make_lambda_1(j[1:]))
                    else:
                        i2.append(make_lambda_2(j))
                #A code token representing a parenthesized block to be recursively
                #    unitized
                else:
                    i2.append(make_lambda_2(self.unitize(j)))
            
            #This is why we put them in reversed order -- each unit needs a reference to
            #    the next (or ACTION_NULL). Ensure the arguments to Unit() are in the
            #    correct format.
            #print i[0], [self.env] + map(lambda f:f(), i2), currunit
            currunit = Unit(i[0], [self.env] + i2, currunit)
        return currunit

with open(argv[1]) as f:
    code = "".join(f.readlines())
    env = Environment("-d" in argv) #Debug flag turns on "print" instruction !
    env(Parser(env, code).unitized)